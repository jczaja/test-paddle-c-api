#include <paddle/capi.h>
#include <opencv2/opencv.hpp>
#include <time.h>
#include <cstring>
#include <vector>

#include "common/common.h"

#define CONFIG_BIN "./trainer_config.bin"

void makeRandomData(paddle_matrix& mat)
{
  paddle_real* array;
  // Get First row.
  CHECK(paddle_matrix_get_row(mat, 0, &array));

  for (int i = 0; i < 784; ++i) {
    array[i] = rand() / ((float)RAND_MAX);
  }
}

/* Wrap the input layer of the network in separate cv::Mat objects
 * (one per channel). This way we save one memcpy 
 * The last preprocessing operation will write the separate channels directly
 * to the input layer. */
// TODO: What is PaddlePaddle data layer format???? (Matrix data format for DataLayer)
// TODO: Finish wrapping around paddle_array

void wrapInputLayerBatch(paddle_matrix& mat, std::vector<std::vector<cv::Mat> >* input_channels_batch) {

  uint64_t width = (*input_channels_batch)[0][0].rows;
  uint64_t height = (*input_channels_batch)[0][0].cols;
  uint64_t channels = 3; 

  // Create input matrix.
  mat = paddle_matrix_create(/* sample_num */ input_channels_batch->size(),
                                         /* size */ width*height*channels,
                                         /* useGPU */ false);

  paddle_real* input_data;
  // Get First row.
  CHECK(paddle_matrix_get_row(mat, 0, &input_data));

  int num = input_channels_batch->size();
  for( int j = 0; j < num; ++j) {
      std::vector<cv::Mat> input_channels;
      for (int i = 0; i < channels; ++i) {
          cv::Mat channel(height, width, CV_32FC1, input_data);
          input_channels.push_back(channel);
          input_data += width * height;
      }
      input_channels_batch->push_back(input_channels);
  }
}

paddle_matrix getImageData(char** argv)
{
  printf("OBRAZEK!!!\n");
  cv::Mat image = cv::imread(argv[1], CV_LOAD_IMAGE_COLOR );

  if (image.data == nullptr) {
    printf("ERROR: Image: %s was not read\n",argv[1]);    
    exit(-1);
  }

  std::vector<std::vector<cv::Mat>> obrazki;
  paddle_matrix mat;

  wrapInputLayerBatch(mat, &obrazki);

  return mat;
}

paddle_matrix prepareData(int mode, char** argv)
{

  // Random data mode
  if(mode == 1) {
    // Create input matrix.
    paddle_matrix mat = paddle_matrix_create(/* sample_num */ 1,
                                           /* size */ 784,
                                           /* useGPU */ false);
    makeRandomData(mat);
    return mat;
  }

  // Image classification mode
  if(mode == 2) {
    return getImageData(argv);
  }
}


int main(int argc, char** argv) {

  if(argc > 2 ) {
    printf("ERROR: Wrong syntax. Valid syntax:\n \
           test-paddle \n \
           test-paddle <name of image to display> \n \
            ");    
    exit(-1);
  }


  // Initalize Paddle
  char* largv[] = {"--use_gpu=False"};
  CHECK(paddle_init(1, (char**)largv));

  // Reading config binary file. It is generated by `convert_protobin.sh`
  long size;
  void* buf = read_config(CONFIG_BIN, &size);

  // Create a gradient machine for inference.
  paddle_gradient_machine machine;
  CHECK(paddle_gradient_machine_create_for_inference(&machine, buf, (int)size));
  CHECK(paddle_gradient_machine_randomize_param(machine));

  // Loading parameter. Uncomment the following line and change the directory.
  // CHECK(paddle_gradient_machine_load_parameter_from_disk(machine,
  //                                                "./some_where_to_params"));
  paddle_arguments in_args = paddle_arguments_create_none();

  // There is only one input of this network.
  CHECK(paddle_arguments_resize(in_args, 1));

  srand(time(0));

  paddle_matrix mat = prepareData(argc, argv);


  CHECK(paddle_arguments_set_value(in_args, 0, mat));

  paddle_arguments out_args = paddle_arguments_create_none();
  CHECK(paddle_gradient_machine_forward(machine,
                                        in_args,
                                        out_args,
                                        /* isTrain */ false));
  paddle_matrix prob = paddle_matrix_create_none();

  CHECK(paddle_arguments_get_value(out_args, 0, prob));

  uint64_t height;
  uint64_t width;

  paddle_real* array;
  CHECK(paddle_matrix_get_shape(prob, &height, &width));
  CHECK(paddle_matrix_get_row(prob, 0, &array));

 
  printf("Prob: \n");
  for (uint64_t i = 0; i < height * width; ++i) {
    printf("%.4f ", array[i]);
    if ((i + 1) % width == 0) {
      printf("\n");
    }
  }
  printf("\n");

  CHECK(paddle_matrix_destroy(prob));
  CHECK(paddle_arguments_destroy(out_args));
  CHECK(paddle_matrix_destroy(mat));
  CHECK(paddle_arguments_destroy(in_args));
  CHECK(paddle_gradient_machine_destroy(machine));

  return 0;
}
